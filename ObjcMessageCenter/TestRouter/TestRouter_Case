1. 测试向上级发送包,执行语句块(VC_A订阅修改文本包,ViewA发送修改文本包,VC_A能收到包,并将文本内容显示到标题);
2. 测试向上级发送包,执行不带参数的方法(VC_A订阅修改文本包,ViewA发送修改文本包,VC_A能收到包,并将文本内容显示到标题);
3. 测试向上级发送包,执行带参数的方法(VC_A订阅修改文本包,ViewA发送修改文本包,VC_A能收到包,并将文本内容显示到标题);
4. 测试向上级发送两个不同的包(ViewB订阅修改文本包和修改字体包,ViewA发送修改文本包和修改字体包,ViewB接收到两个包,并修改文本和字体);
5. 测试向同一个包添加一个语句块和一个方法(ViewB订阅一个执行块的修改文本包,并订阅一个执行方法的修改文本包,ViewA发送修改文本包,ViewB收到包,并执行包和方法);
6. 测试向上级发送包并回调(VC_A订阅修改文本包,ViewA发送修改文本包,VC_A能收到包,并将文本内容显示到标题,然后回调显示新的文本到ViewA);
7. 测试向上级发送包并返回(VC_A订阅修改文本包,ViewA发送修改文本包,VC_A能收到包,并将文本内容显示到标题,然后返回显示新的文本到ViewA);
8. 测试向上级及上级的上级发送包(ViewB和VC_A同时订阅修改文本包,ViewA发送修改文本包,ViewB接受到文本并显示,ViewB的postFlag设为继续发送,VC_A能收到包,并将文本内容显示到标题);
9. 测试向上级及上级的上级发送包并回调(ViewB和VC_A同时订阅修改文本包,ViewA发送修改文本包,ViewB接受到文本并显示并回调显示新的文本到ViewA,VC_A能收到包,并将文本内容显示到标题);
10. 测试向上级及上级的上级发送包,但中途处理完后,停止继续发送(ViewB和VC_A同时订阅修改文本包,ViewA发送修改文本包,ViewB接受到文本并显示后停止转发,VC_A不能收到包);
11. 测试向上级及上级的上级发送包,但中途处理完后,返回(ViewB和VC_A同时订阅修改文本包,ViewA发送修改文本包,ViewB接受到文本并显示后返回,并携带新的文本信息显示到ViewA,VC_A不能收到包);
12. 测试向上级及上级的上级发送包,并返回(ViewB和VC_A同时订阅修改文本包,ViewA发送修改文本包,ViewB接受到文本并显示,VC_A收到包,并显示内容到标题,然后返回,ViewB和ViewA处理返回包);
13. 测试移除指定包订阅(执行4,移除ViewB的对修改文本包的订阅,ViewA发送修改文本包,ViewB接受不到包,VC_A接受到包,并将文本显示到标题);
14. 测试移除所有包的订阅(在ViewB和VC_A添加修改字体包的订阅,ViewA发送修改字体包,ViewB和VC_A成功接收到包;执行4;移除B对所有包的订阅,ViewA发送修改文本包,ViewB接受不到包,VC_A接收到包,并修改标题,ViewA发送修改字体包,ViewB接收不到包,VC_A接收到包并修改标题大小);
15. 测试指定上级(将ViewA的上级制定为ViewC,ViewB和ViewC同时订阅修改文本包,ViewA发送修改文本包,ViewB收不到包,ViewC收到包并显示文本,注意查看dealloc是否有执行);
16. 测试指定上级(将ViewA的上级制定为VC_A,ViewB和VC_A同时订阅修改文本包,ViewA发送修改文本包,ViewB收不到包,VC_A收到包并修改标题,注意查看dealloc是否有执行);
17. 测试指定上级后返回(将ViewA的上级制定为ViewC,ViewB和ViewC同时订阅修改文本包,ViewA发送修改文本包,ViewB收不到包,ViewC收到包并显示文本然后返回,注意查看dealloc是否有执行);
18. 测试指定上级后返回(将ViewA的上级制定为VC_A,ViewB和VC_A同时订阅修改文本包,ViewA发送修改文本包,ViewB收不到包,VC_A收到包并修改标题后返回,注意查看dealloc是否有执行);
19. 向上传递以及返回的各个节点查看source和target,看是否是正确的值,并注意查看dealloc是否执行);

